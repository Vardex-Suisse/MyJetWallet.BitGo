using System;
using System.Collections.Generic;
using Newtonsoft.Json;
// ReSharper disable InconsistentNaming

namespace MyJetWallet.BitGo.Models.Express
{
    public class SendManyRequestData
    {
        /// <summary>
        /// Recipients of coins
        /// </summary>
        [JsonProperty("recipients")]
        public List<Recipient> Recipients { get; set; }
        /// <summary>
        /// Passphrase to decrypt the user key on the wallet
        /// </summary>
        [JsonProperty("walletPassphrase")]
        public string WalletPassphrase { get; set; }

        /// <summary>
        /// Optional, private key in string form, if walletPassphrase is not available or encrypted private key is not stored by BitGo.
        /// </summary>
        [JsonProperty("prv", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string PrivateKey { get; set; }

        /// <summary>
        /// (BTC only) Used to estimate the fee rate by targeting confirmation within the given number of blocks. If neither feeRate nor numBlocks is specified, a block target of 2 is used by default. Can be limited by means of maxFeeRate.
        /// integer [ 2 .. 1000 ]
        /// </summary>
        [JsonProperty("numBlocks", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public int NumBlocks { get; set; }

        /// <summary>
        /// Custom fee rate in satoshis/litoshis/zatoshis/duffs/base units per kilobyte See this support page for more info
        /// Integer
        /// </summary>
        [JsonProperty("feeRate", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string FeeRate { get; set; }

        /// <summary>
        /// Custom upper limit for fee rate in satoshis/litoshis/zatoshis/duffs per kilobyte, may be used to limit a fee rate estimate generated by means of numBlocks
        /// Integer
        /// </summary>
        [JsonProperty("maxFeeRate", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string MaxFeeRate { get; set; }

        /// <summary>
        /// The unspent selection for the transaction will only consider unspents with at least this many confirmations to be used as inputs. Does not apply to change outputs unless used in combination with enforceMinConfirmsForChange.
        /// </summary>
        [JsonProperty("minConfirms", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public int MinConfirms { get; set; }

        /// <summary>
        /// When set to true, will enforce minConfirms for change outputs. Defaults to false.
        /// </summary>
        [JsonProperty("enforceMinConfirmsForChange", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public bool EnforceMinConfirmsForChange { get; set; }

        /// <summary>
        /// Custom gas price to be used for sending the transaction. Only for ETH and ERC20 tokens.
        /// </summary>
        [JsonProperty("gasPrice", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public int GasPrice { get; set; }

        /// <summary>
        /// Custom gas limit to be used for sending the transaction. Only for ETH and ERC20 tokens.
        /// </summary>
        [JsonProperty("gasLimit", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public int GasLimit { get; set; }

        /// <summary>
        /// Specifies the minimum count of good-sized unspents to maintain in the wallet. Change splitting ceases when the wallet has targetWalletUnspents good-sized unspents.
        /// Default: 1000
        ///
        /// Note: Wallets that continuously send a high count of transactions will automatically split large change amounts into multiple good-sized change outputs while they have fewer than targetWalletUnspents good-sized unspents in their unspent pool. Breaking up large unspents helps to reduce the amount of unconfirmed funds in flight in future transactions, and helps to avoid long chains of unconfirmed transactions. This is especially useful for newly funded wallets or recently refilled send-only wallets.
        /// </summary>
        [JsonProperty("targetWalletUnspents", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public long targetWalletUnspents { get; set; }

        /// <summary>
        /// Ignore unspents smaller than this amount of base units (e.g. satoshis)
        /// </summary>
        [JsonProperty("minValue", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public long minValue { get; set; }

        /// <summary>
        /// Ignore unspents larger than this amount of base units (e.g. satoshis)
        /// </summary>
        [JsonProperty("maxValue", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public long MaxValue { get; set; }

        /// <summary>
        /// A sequenceId allows API consumers to create transactions with a unique identifier they can use to reference the transaction later. If a transaction is created with a sequenceId, that identifier can be used to fetch the transaction from the API at a later point in time. The API does not allow the same sequenceId to be used to identify more than one transaction within a wallet. The sequenceId is only visible to users on the wallet and is not shared publicly.
        /// </summary>
        [JsonProperty("sequenceId", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string SequenceId { get; set; }

        /// <summary>
        /// Set true to disable automatic change splitting.
        /// Also see: targetWalletUnspents
        /// 
        /// Default: false
        /// </summary>
        [JsonProperty("noSplitChange", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public bool NoSplitChange { get; set; }

        /// <summary>
        /// Used to explicitly specify the unspents to be used in the input set in the transaction. Each unspent should be in the form prevTxId:nOutput.
        /// </summary>
        [JsonProperty("unspents", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string[] Unspents { get; set; }

        /// <summary>
        /// Specifies a custom destination address for the transaction's change output(s)
        /// string <= 250 characters
        /// </summary>
        [JsonProperty("changeAddress", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string ChangeAddress { get; set; }

        /// <summary>
        /// (DASH only) Specifies whether or not to use Dash's "InstantSend" feature when sending a transaction.
        /// </summary>
        [JsonProperty("instant", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public bool Instant { get; set; }

        /// <summary>
        /// Memo for Stellar or EOS. Type is only required for memos in Stellar transactions. The memo contains optional extra information that can also be used to identify payments in Stellar or EOS.
        /// </summary>
        [JsonProperty("memo", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public MemoType Memo { get; set; }

        /// <summary>
        /// Optional metadata (only persisted in BitGo) to be applied to the transaction. Use this to add transaction-specific information such as the transaction's purpose or another identifier that you want to reference later. The value is shown in the UI in the transfer listing page.
        /// string <= 256 characters
        /// </summary>
        [JsonProperty("comment", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string Comment { get; set; }

        /// <summary>
        /// The type of address to create for change. One of p2sh, p2shP2wsh, and p2wsh.
        /// </summary>
        [JsonProperty("addressType", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string AddressType { get; set; }

        /// <summary>
        /// The start of the validity window for the transaction. Only supported by HBAR
        /// </summary>
        [JsonProperty("startTime", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string StartTime { get; set; }

        /// <summary>
        /// string ^[0-9a-f]{32}$
        /// </summary>
        [JsonProperty("consolidateId", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string consolidateId { get; set; }

        /// <summary>
        /// (XRP only) Absolute max ledger the transaction should be accepted in, whereafter it will be rejected
        /// </summary>
        [JsonProperty("lastLedgerSequence", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public int LastLedgerSequence { get; set; }

        /// <summary>
        /// (XRP only) Relative ledger height (in relation to the current ledger) that the transaction should be accepted in, whereafter it will be rejected
        /// </summary>
        [JsonProperty("ledgerSequenceDelta", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public int LedgerSequenceDelta { get; set; }

        /// <summary>
        /// The list of transactions to bump with a child-pays-for-parent transaction (currently only bumping one tx is supported).
        /// </summary>
        [JsonProperty("cpfpTxIds", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string[] CpfpTxIds { get; set; }

        /// <summary>
        /// The desired effective fee rate of the accelerated transaction in base units per kilobyte (e.g. satoshi/kB), the unconfirmed transactions it depends on, and the newly created child-pays-for-parent transaction. Must be higher than the current effective fee rate of the target transaction.
        /// </summary>
        [JsonProperty("cpfpFeeRate", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public int CpfpFeeRate { get; set; }

        /// <summary>
        /// Limits the amount of satoshis that can be used for fees in a child-pays-for-parent (CPFP) transaction. CPFP transactions accelerate the targeted transaction and all of the unconfirmed transactions the targeted transaction depends on. maxFee is required for all CPFP transactions as it allows users to set a safety net that will halt CPFP attempts that exceed the expected cost.
        /// </summary>
        [JsonProperty("maxFee", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public int MaxFee { get; set; }

        /// <summary>
        /// Required for OFC
        /// integer [ 1 .. 1 ]
        /// </summary>
        [JsonProperty("idfVersion", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public int IdfVersion { get; set; }

        /// <summary>
        /// Required for OFC, datetime of the user accepting the idf. Must be parseable by Date.
        /// </summary>
        [JsonProperty("idfSignedTimestamp", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string IdfSignedTimestamp { get; set; }

        /// <summary>
        /// Required for OFC, user ID of the user who accepted the idf.
        /// </summary>
        [JsonProperty("idfUserId", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string IdfUserId { get; set; }

        /// <summary>
        /// Optional unspent selection strategy to use. One of RANDOM, FIFO or BNB.
        /// string <= 20 characters
        /// </summary>
        [JsonProperty("strategy", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string Strategy { get; set; }

        /// <summary>
        /// Optional block this transaction is valid from
        /// </summary>
        [JsonProperty("validFromBlock", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public int ValidFromBlock { get; set; }

        /// <summary>
        /// Optional block this transaction is valid until
        /// </summary>
        [JsonProperty("validToBlock", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public int ValidToBlock { get; set; }

        /// <summary>
        /// transaction type (e.g. trustline for Stellar trustline transactions and accountSet for xrp account set transactions)
        /// </summary>
        [JsonProperty("type", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>
        /// List of trustlines to manage on the account. Available for Stellar.
        /// </summary>
        [JsonProperty("trustlines", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public StellarTrustline[] Trustlines { get; set; }

        /// <summary>
        /// Optional parameter for UTXO coins to automatically reserve the unspents that are used in the build. Useful for Cold wallets. If using, must set expireTime.
        /// </summary>
        [JsonProperty("reservation", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public ReservationType Reservation { get; set; }

        /// <summary>
        /// (ETH only) Optional data to pass to the transaction
        /// </summary>
        [JsonProperty("data", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string Data { get; set; }

        public class StellarTrustline
        {
            [JsonProperty("token")] public string Token { get; set; }

            [JsonProperty("action")] public string Action { get; set; }

            [JsonProperty("limit")] public string Limit { get; set; }
        }

        public class ReservationType
        {
            [JsonProperty("expireTime")]
            public DateTime expireTime { get; set; }
        }

        public class Recipient
        {
            /// <summary>
            /// Destination address(<= 250 characters)
            /// </summary>
            [JsonProperty("address")]
            public string Address { get; set; }

            /// <summary>
            /// Transfer amount
            /// Integer
            /// </summary>
            [JsonProperty("amount")]
            public string Amount { get; set; }
        }

        public class MemoType
        {
            [JsonProperty("type", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public MemoEnum Type { get; set; }

            [JsonProperty("value", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string Value { get; set; }

            public enum MemoEnum
            {
                [JsonProperty("id")]
                id
            }
        }
    }


}